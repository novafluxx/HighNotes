<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Test</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .test-result { padding: 10px; margin: 5px 0; border-radius: 5px; }
        .test-pass { background-color: #d4edda; color: #155724; }
        .test-fail { background-color: #f8d7da; color: #721c24; }
        .test-summary { font-weight: bold; margin-top: 20px; }
        button { background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; }
        button:hover { background: #0056b3; }
        #results { margin-top: 20px; }
    </style>
</head>
<body>
    <h1>üß™ Crypto Functionality Test</h1>
    <p>This page tests the client-side encryption utilities for High Notes.</p>
    
    <button onclick="runCryptoTests()">Run Tests</button>
    
    <div id="results"></div>

    <script type="module">
        // Simple implementation of crypto utilities for testing
        import { argon2id } from 'https://esm.sh/@noble/hashes@2.0.0/argon2';
        import { deflate, inflate } from 'https://esm.sh/pako@2.1.0';

        const CRYPTO_VERSION = 1;
        const ENCRYPTION_ALGORITHM = 'AES-GCM';
        const COMPRESSION_METHOD = 'gzip';
        const KEY_SIZE = 256;
        const IV_SIZE = 12;
        const SALT_SIZE = 16;

        // Utility functions
        const generateRandomBytes = (size) => crypto.getRandomValues(new Uint8Array(size));
        
        const arrayBufferToBase64 = (buffer) => {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        };

        const base64ToArrayBuffer = (base64) => {
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes;
        };

        const deriveKey = async (password, salt = generateRandomBytes(SALT_SIZE)) => {
            const keyMaterial = argon2id(password, salt, {
                t: 3, m: 65536, p: 1, dkLen: KEY_SIZE / 8
            });

            const key = await crypto.subtle.importKey(
                'raw', keyMaterial, { name: 'AES-GCM' }, false, 
                ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']
            );

            return { key, salt };
        };

        const generateDEK = () => crypto.subtle.generateKey(
            { name: 'AES-GCM', length: KEY_SIZE }, true, ['encrypt', 'decrypt']
        );

        const wrapDEK = async (dek, masterKey) => {
            const iv = generateRandomBytes(IV_SIZE);
            const wrappedKey = await crypto.subtle.wrapKey('raw', dek, masterKey, {
                name: 'AES-GCM', iv
            });
            return {
                algorithm: ENCRYPTION_ALGORITHM,
                iv: arrayBufferToBase64(iv),
                encrypted_key: arrayBufferToBase64(wrappedKey)
            };
        };

        const unwrapDEK = async (wrappedDEK, masterKey) => {
            const iv = base64ToArrayBuffer(wrappedDEK.iv);
            const encryptedKey = base64ToArrayBuffer(wrappedDEK.encrypted_key);
            return await crypto.subtle.unwrapKey(
                'raw', encryptedKey, masterKey, { name: 'AES-GCM', iv },
                { name: 'AES-GCM' }, false, ['encrypt', 'decrypt']
            );
        };

        const encryptNote = async (plaintext, masterKey) => {
            const plaintextJson = JSON.stringify(plaintext);
            const encoder = new TextEncoder();
            const utf8Data = encoder.encode(plaintextJson);
            const compressed = deflate(utf8Data);
            
            const dek = await generateDEK();
            const iv = generateRandomBytes(IV_SIZE);
            
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv }, dek, compressed
            );
            
            const wrappedDEK = await wrapDEK(dek, masterKey);

            return {
                version: CRYPTO_VERSION,
                algorithm: ENCRYPTION_ALGORITHM,
                compression: COMPRESSION_METHOD,
                iv: arrayBufferToBase64(iv),
                encrypted_data: arrayBufferToBase64(encrypted),
                wrapped_dek: wrappedDEK
            };
        };

        const decryptNote = async (encryptedPayload, masterKey) => {
            const dek = await unwrapDEK(encryptedPayload.wrapped_dek, masterKey);
            const iv = base64ToArrayBuffer(encryptedPayload.iv);
            const encryptedData = base64ToArrayBuffer(encryptedPayload.encrypted_data);
            
            const decrypted = await crypto.subtle.decrypt(
                { name: 'AES-GCM', iv }, dek, encryptedData
            );
            
            const decompressed = inflate(new Uint8Array(decrypted));
            const decoder = new TextDecoder();
            const plaintextJson = decoder.decode(decompressed);
            
            return JSON.parse(plaintextJson);
        };

        // Test functions
        window.runCryptoTests = async function() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<h2>Running tests...</h2>';
            
            let passed = 0;
            let failed = 0;
            const results = [];

            const test = async (name, fn) => {
                try {
                    await fn();
                    results.push(`<div class="test-result test-pass">‚úÖ ${name}</div>`);
                    passed++;
                } catch (error) {
                    results.push(`<div class="test-result test-fail">‚ùå ${name}: ${error.message}</div>`);
                    failed++;
                }
            };

            try {
                await test('Generate random bytes', () => {
                    const bytes = generateRandomBytes(16);
                    if (bytes.length !== 16) throw new Error('Wrong length');
                });

                await test('Base64 conversion', () => {
                    const original = new Uint8Array([1, 2, 3, 4, 5]);
                    const base64 = arrayBufferToBase64(original);
                    const decoded = base64ToArrayBuffer(base64);
                    if (JSON.stringify(decoded) !== JSON.stringify(original)) {
                        throw new Error('Conversion failed');
                    }
                });

                await test('Key derivation', async () => {
                    const { key, salt } = await deriveKey('test-password');
                    if (!(key instanceof CryptoKey)) throw new Error('Not a CryptoKey');
                    if (salt.length !== SALT_SIZE) throw new Error('Wrong salt size');
                });

                await test('DEK operations', async () => {
                    const { key: masterKey } = await deriveKey('test-password');
                    const dek = await generateDEK();
                    const wrapped = await wrapDEK(dek, masterKey);
                    const unwrapped = await unwrapDEK(wrapped, masterKey);
                    if (!(unwrapped instanceof CryptoKey)) throw new Error('Unwrap failed');
                });

                await test('Note encryption/decryption', async () => {
                    const testData = { title: 'Test', content: 'Content with unicode: üöÄ' };
                    const { key } = await deriveKey('test-password');
                    const encrypted = await encryptNote(testData, key);
                    const decrypted = await decryptNote(encrypted, key);
                    if (JSON.stringify(decrypted) !== JSON.stringify(testData)) {
                        throw new Error('Round trip failed');
                    }
                });

                await test('Large content handling', async () => {
                    const largeData = { 
                        title: 'Large Note',
                        content: 'A'.repeat(10000) // 10KB content
                    };
                    const { key } = await deriveKey('test-password');
                    const encrypted = await encryptNote(largeData, key);
                    const decrypted = await decryptNote(encrypted, key);
                    if (JSON.stringify(decrypted) !== JSON.stringify(largeData)) {
                        throw new Error('Large content round trip failed');
                    }
                });

                await test('Wrong password detection', async () => {
                    const testData = { title: 'Test', content: 'Content' };
                    const { key: key1 } = await deriveKey('password1');
                    const { key: key2 } = await deriveKey('password2');
                    const encrypted = await encryptNote(testData, key1);
                    
                    try {
                        await decryptNote(encrypted, key2);
                        throw new Error('Should have failed with wrong password');
                    } catch (error) {
                        if (error.message === 'Should have failed with wrong password') {
                            throw error;
                        }
                        // Expected to fail - test passes
                    }
                });

                // Display results
                const summary = `
                    <div class="test-summary">
                        üìä Test Results:<br>
                        ‚úÖ Passed: ${passed}<br>
                        ‚ùå Failed: ${failed}<br>
                        üìà Total: ${passed + failed}
                    </div>
                `;

                const features = `
                    <div style="margin-top: 20px; padding: 15px; background: #e7f3ff; border-radius: 5px;">
                        <h3>üîê Implemented Features</h3>
                        <ul>
                            <li>‚úÖ Argon2id-based key derivation</li>
                            <li>‚úÖ Random per-note DEK generation using crypto.getRandomValues</li>
                            <li>‚úÖ Gzip compression before encryption</li>
                            <li>‚úÖ AES-GCM (256-bit) encryption/decryption</li>
                            <li>‚úÖ DEK wrapping/unwrapping with master key</li>
                            <li>‚úÖ Encrypted payload JSON serialization</li>
                            <li>‚úÖ Unicode and large content support</li>
                            <li>‚úÖ Tamper detection and error handling</li>
                            <li>‚úÖ No plaintext or keys stored in persistent storage</li>
                        </ul>
                    </div>
                `;

                resultsDiv.innerHTML = results.join('') + summary + features;

                if (failed === 0) {
                    resultsDiv.innerHTML += '<div style="margin-top: 20px; padding: 15px; background: #d4edda; color: #155724; border-radius: 5px; font-weight: bold;">üéâ All tests passed! Crypto functionality is working correctly.</div>';
                }

            } catch (error) {
                resultsDiv.innerHTML += `<div class="test-result test-fail">üí• Test runner error: ${error.message}</div>`;
            }
        };
    </script>
</body>
</html>